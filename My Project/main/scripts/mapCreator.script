WIDTH = 39
LENGTH = 39

local assetOffset = 35

function init(self)
	math.randomseed(os.time())
	
	for r = -10, WIDTH*6.5 do
		for c = -10, LENGTH*7 do
			local pool = {11,11,11,12,12,12,13,13,13,14,14,14,15,16,17,17,17}
			local tile = pool[math.random(#pool)]
			tilemap.set_tile("/level#generateMap", "background", r, c, tile)
		end
	end

	tilemap.set_tile("/level#generateMap", "roof_doors", 98, 233, 6)
	tilemap.set_tile("/level#generateMap", "roof_doors", 98, 234, 7)
	tilemap.set_tile("/level#generateMap", "roof_doors", 97, 233, 6)
	tilemap.set_tile("/level#generateMap", "roof_doors", 97, 234, 7)
	tilemap.set_tile("/level#generateMap", "roof_doors", 99, 233, 6)
	tilemap.set_tile("/level#generateMap", "roof_doors", 99, 234, 7)
end

function on_message(self, message_id, message, sender)

	local grid = message
	
	roof_rooms = {}

	for i = 1, #grid do
		for j = 1, #grid[1] do
			
			local room = grid[i][j]
			
			if room ~= '' then

				if i == 6 then
					table.insert(roof_rooms, j)
				end

				temp_x = (((j - 1) * WIDTH) + 1)
				temp_y = (((i - 1) * LENGTH) + 1)
				
				room = string.gsub(room, "%^", "")
				room = string.gsub(room, "%v", "")
				room = string.gsub(room, "%<", "")
				room = string.gsub(room, "%>", "")
				
				paint_room_base(room, temp_x, temp_y)

				if string.find(room, "R") ~= nil then
					classroom(temp_x, temp_y, j, i)
				elseif string.find(room, "C") ~= nil then
					cafeteria(temp_x, temp_y, j, i)
				elseif string.find(room, "G") ~= nil then
					gym(temp_x, temp_y, j, i)
				elseif string.find(room, "Boss") ~= nil then
					boss(j, i)
				elseif string.find(room, "End") ~= nil then
					exit(temp_x, temp_y)
				end

				paint_doors(grid, i, j, temp_x, temp_y)
			end
		end
	end

	paint_roof(roof_rooms, #grid)
	
	msg.post('/level#fillEnemies', 'generate', grid)
end

function paint_room_base(room, temp_x, temp_y)
	
	for y = 0, LENGTH-1 do
		for x = 0, WIDTH-1 do
			if y == 0 then
				tilemap.set_tile("/level#generateMap", "walls", temp_x+x, temp_y+y, 57)
				if x ~= 0 and x ~=38 then
					tilemap.set_tile("/level#generateMap", "borders", temp_x+x, temp_y+y, 26)
				end
			elseif x == 0 then
				tilemap.set_tile("/level#generateMap", "walls", temp_x+x, temp_y+y, 57)
				if y ~= 38 then
					tilemap.set_tile("/level#generateMap", "borders", temp_x+x, temp_y+y, 18)
				end
			elseif y == WIDTH-1 then
				tilemap.set_tile("/level#generateMap", "walls", temp_x+x, temp_y+y, 57)
				if x ~= 0 and x ~=38 then
					tilemap.set_tile("/level#generateMap", "borders", temp_x+x, temp_y+y, 24)
				end
			elseif x == LENGTH-1 then
				tilemap.set_tile("/level#generateMap", "walls", temp_x+x, temp_y+y, 57)
				tilemap.set_tile("/level#generateMap", "borders", temp_x+x, temp_y+y, 25)
			else
				floor_tile = select_floor_tile(room)
				tilemap.set_tile("/level#generateMap", "floor", temp_x+x, temp_y+y, floor_tile)
			end
		end
	end
end

function select_floor_tile(room)

	if room == "Spawn" then
		return 54
	elseif room == "C" or room == "Boss" then
		local pool = {1,1,1,1,1,2,2,2,2,2,3,4,4,4,4,4,5}
		return pool[math.random(#pool)]
	elseif room == "R" then
		return math.random(31,34)
	elseif room == "B" or room == "End" then
		local pool = {41,41,41,41,41,42,42,42,42,42,43,43,43,43,43,44,45,45,45,45,45}
		return pool[math.random(#pool)]
	elseif room == "G" then
		local pool = {21,22,23}
		return pool[math.random(#pool)]
	end	
end

function paint_doors(grid, i, j, temp_x, temp_y)
	if string.find(grid[i][j], "%^") ~= nil then

		tilemap.set_tile("/level#generateMap", "walls", temp_x+(LENGTH/2), temp_y, 7)
		tilemap.set_tile("/level#generateMap", "walls", (temp_x+(LENGTH/2))-1, temp_y, 7)
		tilemap.set_tile("/level#generateMap", "walls", (temp_x+(LENGTH/2))+1, temp_y, 7)
		
		tilemap.set_tile("/level#generateMap", "borders", temp_x+(LENGTH/2), temp_y, 0)
		tilemap.set_tile("/level#generateMap", "borders", (temp_x+(LENGTH/2))-1, temp_y, 25)
		tilemap.set_tile("/level#generateMap", "borders", (temp_x+(LENGTH/2))+1, temp_y, 18)

		if string.find(grid[i][j], "End") ~= nil then
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x+(LENGTH/2), temp_y-1, 8)
			tilemap.set_tile("/level#generateMap", "locked_doors", (temp_x+(LENGTH/2))-1, temp_y-1, 8)
			tilemap.set_tile("/level#generateMap", "locked_doors", (temp_x+(LENGTH/2))+1, temp_y-1, 8)
			
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x+(LENGTH/2), temp_y, 9)
			tilemap.set_tile("/level#generateMap", "locked_doors", (temp_x+(LENGTH/2))-1, temp_y, 9)
			tilemap.set_tile("/level#generateMap", "locked_doors", (temp_x+(LENGTH/2))+1, temp_y, 9)
		end
	end

	if string.find(grid[i][j], "v") ~= nil or string.find(grid[i][j], "Spawn") ~= nil then

		tilemap.set_tile("/level#generateMap", "walls", temp_x+(LENGTH/2), temp_y+(WIDTH-1), 6)
		tilemap.set_tile("/level#generateMap", "walls", (temp_x+(LENGTH/2))-1, temp_y+(WIDTH-1), 6)
		tilemap.set_tile("/level#generateMap", "walls", (temp_x+(LENGTH/2))+1, temp_y+(WIDTH-1), 6)
		
		tilemap.set_tile("/level#generateMap", "borders", temp_x+(LENGTH/2), temp_y+(WIDTH-1), 0)
		tilemap.set_tile("/level#generateMap", "borders", (temp_x+(LENGTH/2))-1, temp_y+(WIDTH-1), 25)
		tilemap.set_tile("/level#generateMap", "borders", (temp_x+(LENGTH/2))+1, temp_y+(WIDTH-1), 18)

		if string.find(grid[i][j], "End") ~= nil then
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x+(LENGTH/2), temp_y+(WIDTH), 9)
			tilemap.set_tile("/level#generateMap", "locked_doors", (temp_x+(LENGTH/2))-1, temp_y+(WIDTH), 9)
			tilemap.set_tile("/level#generateMap", "locked_doors", (temp_x+(LENGTH/2))+1, temp_y+(WIDTH), 9)
			
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x+(LENGTH/2), temp_y+(WIDTH-1), 8)
			tilemap.set_tile("/level#generateMap", "locked_doors", (temp_x+(LENGTH/2))-1, temp_y+(WIDTH-1), 8)
			tilemap.set_tile("/level#generateMap", "locked_doors", (temp_x+(LENGTH/2))+1, temp_y+(WIDTH-1), 8)
		end
	end

	if string.find(grid[i][j], "<") ~= nil then

		tilemap.set_tile("/level#generateMap", "walls", temp_x, temp_y+(WIDTH/2), 6, tilemap.ROTATE_270)
		tilemap.set_tile("/level#generateMap", "walls", temp_x, (temp_y+(WIDTH/2))-1, 6, tilemap.ROTATE_270)
		tilemap.set_tile("/level#generateMap", "walls", temp_x, (temp_y+(WIDTH/2))+1, 6, tilemap.ROTATE_270)
		
		tilemap.set_tile("/level#generateMap", "borders", temp_x, temp_y+(WIDTH/2), 0)
		tilemap.set_tile("/level#generateMap", "borders", temp_x, (temp_y+(WIDTH/2))-1, 24)
		tilemap.set_tile("/level#generateMap", "borders", temp_x, (temp_y+(WIDTH/2))+1, 26)

		if string.find(grid[i][j], "End") ~= nil then
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x, temp_y+(WIDTH/2), 8, tilemap.ROTATE_270)
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x, (temp_y+(WIDTH/2))-1, 8, tilemap.ROTATE_270)
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x, (temp_y+(WIDTH/2))+1, 8, tilemap.ROTATE_270)
			
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x-1, temp_y+(WIDTH/2), 9, tilemap.ROTATE_270)
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x-1, (temp_y+(WIDTH/2))-1, 9, tilemap.ROTATE_270)
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x-1, (temp_y+(WIDTH/2))+1, 9, tilemap.ROTATE_270)
		end

	end

	if string.find(grid[i][j], ">") ~= nil then

		tilemap.set_tile("/level#generateMap", "walls", temp_x+(LENGTH-1), temp_y+(WIDTH/2), 7, tilemap.ROTATE_270)
		tilemap.set_tile("/level#generateMap", "walls", temp_x+(LENGTH-1), (temp_y+(WIDTH/2))-1, 7, tilemap.ROTATE_270)
		tilemap.set_tile("/level#generateMap", "walls", temp_x+(LENGTH-1), (temp_y+(WIDTH/2))+1, 7, tilemap.ROTATE_270)
		
		tilemap.set_tile("/level#generateMap", "borders", temp_x+(LENGTH-1), temp_y+(WIDTH/2), 0)
		tilemap.set_tile("/level#generateMap", "borders", temp_x+(LENGTH-1), (temp_y+(WIDTH/2))-1, 24)
		tilemap.set_tile("/level#generateMap", "borders", temp_x+(LENGTH-1), (temp_y+(WIDTH/2))+1, 26)

		if string.find(grid[i][j], "End") ~= nil then
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x+(LENGTH-1), temp_y+(WIDTH/2), 9, tilemap.ROTATE_270)
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x+(LENGTH-1), (temp_y+(WIDTH/2))-1, 9, tilemap.ROTATE_270)
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x+(LENGTH-1), (temp_y+(WIDTH/2))+1, 9, tilemap.ROTATE_270)
			
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x+(LENGTH-1)+1, temp_y+(WIDTH/2), 8, tilemap.ROTATE_270)
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x+(LENGTH-1)+1, (temp_y+(WIDTH/2))-1, 8, tilemap.ROTATE_270)
			tilemap.set_tile("/level#generateMap", "locked_doors", temp_x+(LENGTH-1)+1, (temp_y+(WIDTH/2))+1, 8, tilemap.ROTATE_270)
		end
	end
end

function classroom(temp_x, temp_y, j, i)

	factory.create("/mapAssets#blackboard_factory", vmath.vector3(calc_asset_pos(WIDTH/2, temp_x, 1, j*4), calc_asset_pos(LENGTH-3, temp_y, -2, i*4), 0.99), nil, nil, 1)

	-- Minimum distance between desks
	local minDistance = 80

	-- Table to store positions of generated desks
	local deskPositions = {}

	for m = 1, 20 do
		local deskX, deskY

		-- Generate desk position and ensure it doesn't overlap with previous desks
		repeat
			deskX = math.random(calc_asset_pos(WIDTH/2, temp_x, -6, j*4), calc_asset_pos(WIDTH/2, temp_x, 10, j*4))
			deskY = math.random(calc_asset_pos(LENGTH/2, temp_y, -6, i*4), calc_asset_pos(LENGTH/2, temp_y, 10, i*4))

			-- Check overlap with previous desks
			local overlap = false
			for _, pos in ipairs(deskPositions) do
				if math.abs(deskX - pos.x) < minDistance and math.abs(deskY - pos.y) < minDistance then
					overlap = true
					break
				end
			end
		until not overlap

		-- Store current desk position
		table.insert(deskPositions, {x = deskX, y = deskY})

		-- Create desk entity
		factory.create("/mapAssets#desk_factory", vmath.vector3(deskX, deskY, 0.99), nil, nil, 1)

		--place papers around desk area
		factory.create("/mapAssets#paper_factory", vmath.vector3(deskX+2, deskY+80, 0.99), nil, nil, 1)	
		factory.create("/mapAssets#paper_factory", vmath.vector3(deskX+2, deskY-80, 0.99), nil, nil, 1)
		factory.create("/mapAssets#paper_factory", vmath.vector3(deskX+60, deskY, 0.99), nil, nil, 1)
		factory.create("/mapAssets#paper_factory", vmath.vector3(deskX-60, deskY, 0.99), nil, nil, 1)
	end
end

function cafeteria(temp_x, temp_y, j, i)

	local x_offset_vals = {-2, 0, 1, 2, 4}

	for k = 1, #x_offset_vals do

		if x_offset_vals[k] == 1 then
			factory.create("/mapAssets#table_factory", vmath.vector3(calc_asset_pos(WIDTH/2, temp_x, x_offset_vals[k], j*4), calc_asset_pos(LENGTH/2, temp_y, -1, i*4), 0.90), nil, nil, 1)
			factory.create("/mapAssets#table_factory", vmath.vector3(calc_asset_pos(WIDTH/2, temp_x, x_offset_vals[k], j*4), calc_asset_pos(LENGTH-3, temp_y, -1, i*4), 0.90), nil, nil, 1)
			
		else
			factory.create("/mapAssets#tray_factory", vmath.vector3(calc_asset_pos(WIDTH/2, temp_x, x_offset_vals[k], j*4), calc_asset_pos(LENGTH/2, temp_y, 0, i*4), 0.90), nil, nil, 1)
			factory.create("/mapAssets#tray_factory", vmath.vector3(calc_asset_pos(WIDTH/2, temp_x, x_offset_vals[k], j*4), calc_asset_pos(LENGTH-3, temp_y, 0, i*4), 0.90), nil, nil, 1)
		end
	end
end

function gym(temp_x, temp_y, j, i)
	
	local hoopX = calc_asset_pos(WIDTH/2, temp_x, 1, j*4)
	
	factory.create("/mapAssets#hoop_factory", vmath.vector3(hoopX, calc_asset_pos(LENGTH/2, temp_y, -2, i*4), 0.99), nil, nil, 1)
	factory.create("/mapAssets#hoop_factory", vmath.vector3(hoopX, calc_asset_pos(LENGTH-3, temp_y, -2, i*4), 0.99), nil, nil, 1)
end

function boss(temp_x, temp_y)
	local coords = {}
	local chefX = ((((temp_x-1)*WIDTH)*30)+(625)) + (temp_x*50)
	local chefY = ((((temp_y-1)*LENGTH)*30)+(1025)) + (temp_y*75)

	table.insert(coords, chefX)
	table.insert(coords, chefY)
	msg.post("/chefBoss#chef_boss", 'placeChef', coords)
end

function exit(temp_x, temp_y)
	local coords = {}
	local cloudX = ((WIDTH-1)/2) + temp_x
	local cloudY = ((LENGTH-1)/2) + temp_y
	
	table.insert(coords, cloudX)
	table.insert(coords, cloudY)
	msg.post("/cloud-exit#cloudSprite", 'createCloud', coords)
end

function calc_asset_pos(room_position, map_position, room_offset, map_offset)
	return (((room_position)+map_position+room_offset-(map_offset))*assetOffset)
end

function paint_roof(roof_rooms, top_x)
	previous = -1
	for i, room in ipairs(roof_rooms) do

		temp_x = (((room - 1) * WIDTH) + 1)
		temp_y = (((top_x - 1) * LENGTH) + 1)

		for y = 0, LENGTH-1 do
			for x = 0, WIDTH-1 do
				tilemap.set_tile("/level#generateMap", "roof", temp_x+x, temp_y+y, 19)

				if y == 38 then
					tilemap.set_tile("/level#generateMap", "roof", temp_x+x, temp_y+y, 39)
				end
				
				if (room - previous) > 1 then
					if x == 0 then
						if y==38 then
							tilemap.set_tile("/level#generateMap", "roof", temp_x+x, temp_y+y, 10)
						else
							tilemap.set_tile("/level#generateMap", "roof", temp_x+x, temp_y+y, 49)
						end
					end
				end

				if roof_rooms[i+1] ~= null then

					if (roof_rooms[i+1] - room > 1) then
						if x == LENGTH-1 then
							if y==38 then
								tilemap.set_tile("/level#generateMap", "roof", temp_x+x, temp_y+y, 20)
							else
								tilemap.set_tile("/level#generateMap", "roof", temp_x+x, temp_y+y, 59)
							end
						end
					end

				else
					if x == WIDTH-1 then
						if y==38 then
							tilemap.set_tile("/level#generateMap", "roof", temp_x+x, temp_y+y, 20)
						else
							tilemap.set_tile("/level#generateMap", "roof", temp_x+x, temp_y+y, 59)
						end
					end
				end
			end
		end
		previous = room		
	end
end