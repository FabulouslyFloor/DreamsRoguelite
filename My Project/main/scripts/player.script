--[[
Script Name: player
Author(s): Henry Hauger, Florian Hurlbert
Date of Last Change: 5/6/2024

Scripts Referenced/Messaged: GUI, weapon factory, rocket factory

Script Purpose: runs the player and their motion, attacks, and damage logic
]]

-- Local Variables Initialized
local speed = 300
local attacking = false
-- Animation Variable
local anim = nil
-- Melee attack flag
local weaponAcquired = false
local attackMelee = true
local meleeWeaponAcquired = false
local rangedWeaponAcquired = false
-- Timers
local weaponSwitchTimer = 0
local attackingTimer = 0

local roofVisible = true
local exitDoorsVisible = true

local function on_death(self)
	-- removes control from player
	msg.post("mapGeneration:/guis#death_screen", "dead!")
	msg.post(".", "release_input_focus")
	print("you died!")
	go.delete()
end

-- happens when player collides with an object with group 'enemy_body' (todo: if enemies hit in ways other than melee, add group 'enemy_attack')
local function on_damage(self, given_normal,trigger)
	-- play damage sound effect
	sound.play("#on_hurt")
	-- take away 1 hp
	self.health = self.health - 1
	-- send message to gui to remove heart, activate damage cooldown
	msg.post("mapGeneration:/health_gui#player_health", "lost_health")
	-- if  hp at 0, kill player
	if self.health == 0 then
		on_death(self)
	else
		self.damaged = true
		self.damage_cooldown = 120
		if trigger then
			self.knocked_back = true
			self.dir = given_normal
			self.knockback_cooldown = 60
		end
	end
end

function init(self)
	-- Acquires input focus to recieve inputs
	msg.post(".", "acquire_input_focus")
	-- Sets up internal variables
	self.dir = vmath.vector3()
	self.current_anim = nil
	self.firing = false
	self.health = 5
	self.damage_cooldown = 0
	self.damaged = false
	self.knocked_back = false
	self.knockback_cooldown = 0
	self.current_location = "outside" -- todo: will be used to help determine what walking sound to use
	self.in_item_range = false
	self.itemNear = hash("")

	self.keys = 0
	self.key2id = hash("nothing")
end

function update(self, dt)
	-- 
	if self.damage_cooldown > 0 then
		self.damage_cooldown = self.damage_cooldown - 1
	elseif self.damaged == true then
		self.damaged = false
	end

	-- Checks if the direction is greater than one and normalizes it if it is
	if vmath.length_sqr(self.dir) > 1 then
		self.dir = vmath.normalize(self.dir)
	end

	if weaponSwitchTimer ~= 0 then
		weaponSwitchTimer = weaponSwitchTimer - 1
	end

	-- Checks is self.firing is true meaning the player has clicked to shoot
	--if self.firing then
		-- Calculates the angle using the players y and x direction
		--local angle = math.atan2(self.dir.y, self.dir.x)
		-- Calculates the rotation using the angle
		--local rot = vmath.quat_rotation_z(angle)
		-- Sets up a table with the players direction to pass to the bullet
		--local props = { dir = self.dir }
		-- Calls the correct factory and passes the information
		--factory.create("#rocketfactory", nil, rot, props)
		-- sets self firing to false
		--self.firing = false
	--end

	-- Checks if attacking to prevent moving while attacking
	if not attacking and dt ~= 0 then
		-- Gets position, then resets it using the players inner variables 
		local p = go.get_position()
		go.set_position(p + self.dir * speed * dt) 

		-- counts down knockback if it's still going, if timer hits 0 then exit knockback state
		if self.knockback_cooldown > 0 then
			self.knockback_cooldown = self.knockback_cooldown - 1
		elseif self.knocked_back == true then
			self.knocked_back = false
		end

		-- Sets to Idle by default 
		local anim = hash("idle")

		-- TODO: DAMAGED STATE OVERRIDES DIRECTIONS. BY DESIGN AS PLACEHOLDER. 
		if self.damaged == true then
			anim = hash("hit")
		-- Checks the X and Y directions to determine the animation to play - prioritizes X over Y
		elseif self.dir.x > 0 and dt ~= 0 then  
			anim = hash("run_right")
		elseif self.dir.x < 0 and dt ~= 0 then
			anim = hash("run_left")
		elseif self.dir.y > 0 and dt ~= 0 then
			anim = hash("run_up")
		elseif self.dir.y < 0 and dt ~= 0 then
			anim = hash("run_down")
		end

		if self.dir ~= vmath.vector3() and self.current_anim == hash("idle") then -- if the player is about to start moving
			sound.play("#walking") -- play walking noises
		end

		-- If the anim variable doesn't match the internal variable
		if anim ~= self.current_anim then
			-- Sends a message to the sprite component to play the new animation
			msg.post("#sprite", "play_animation", { id = anim })
			self.current_anim = anim 
			if anim == hash("idle") then -- used to detect if player is going idle, turns off walking noises
				sound.stop("#walking")
			end
		end

		-- resets movement vector to 0,0,0 unless player is still being knocked back
		if not self.knocked_back then
			self.dir = vmath.vector3() 
		end 

	end
end

function on_message(self, message_id, message, sender)
	-- Checks for attack messages

	if message_id == hash("play attack") and weaponAcquired and dt ~= 0 then
		-- Checks if the player is not already currently attacking or playing the damaged animation
		if not attacking and self.damage_cooldown == 0 then
			-- Saves the animation being played currently
			anim = self.current_anim
			-- If the player is on Melee weapon
			if attackMelee and meleeWeaponAcquired then
				-- Checks which direction the player was facing based on animation 
				-- Plays the proper attack animation
				-- Spawns a weapon object with the direction animation which plays the proper animation
				if anim == hash("run_right") and dt ~= 0 then
					msg.post(".", "play_animation", {id = hash("melee_right")})
					local props = { anim = hash("melee_right_sword") }
					factory.create("#Weaponfactory",nil,nil,props)
					--msg.post(id, "id", {)
				elseif anim == hash("run_left") and dt ~= 0 then
					msg.post(".", "play_animation", {id = hash("melee_left")})
					local props = { anim = hash("melee_left_sword") }
					factory.create("#Weaponfactory",nil,nil,props)
				elseif anim == hash("run_up") and dt ~= 0 then
					msg.post(".", "play_animation", {id = hash("melee_up")})
					local props = { anim = hash("melee_up_sword") }
					factory.create("#Weaponfactory",nil,nil,props)
				elseif anim == hash("run_down") and dt ~= 0 then
					msg.post(".", "play_animation", {id = hash("melee_down")})
					local props = { anim = hash("melee_down_sword") }
					factory.create("#Weaponfactory",nil,nil,props)
				elseif anim == hash("idle") and dt ~= 0 then
					msg.post(".", "play_animation", {id = hash("melee_down")})
					local props = { anim = hash("melee_down_sword") }
					factory.create("#Weaponfactory",nil,nil,props)
				end
			elseif attackMelee == false and rangedWeaponAcquired then
				-- Checks which direction the player was facing based on animation 
				-- Plays the proper attack animation
				-- Sets self.firing to true so the firing code in update happens
				if anim == hash("run_right") and dt ~= 0 then
					msg.post(".", "play_animation", {id = hash("ranged_right")})
					--self.firing = true
					local props = { dir = hash("right") }
					factory.create("#rocketfactory",nil,nil,props)
				elseif anim == hash("run_left") and dt ~= 0 then
					msg.post(".", "play_animation", {id = hash("ranged_left")})
					--self.firing = true
					local props = { dir = hash("left") }
					factory.create("#rocketfactory",nil,nil,props)
				elseif anim == hash("run_up") and dt ~= 0 then
					msg.post(".", "play_animation", {id = hash("ranged_up")})
					--self.firing = true
					local props = { dir = hash("up") }
					factory.create("#rocketfactory",nil,nil,props)
				elseif anim == hash("run_down") and dt ~= 0 then
					msg.post(".", "play_animation", {id = hash("ranged_down")})
					--self.firing = true
					local props = { dir = hash("down") }
					factory.create("#rocketfactory",nil,nil,props)
				elseif anim == hash("idle") and dt ~= 0 then
					msg.post(".", "play_animation", {id = hash("melee_down")})
					--self.firing = true
					local props = { dir = hash("down") }
					factory.create("#rocketfactory",nil,nil,props)
				end
			end
			-- Sets attacking to true to stop the player from moving during the attack animation
			attacking = true
		end
	end
	-- The "play_animation" message sends an "animation_done" message when it finishes playing
	if message_id == hash("animation_done") then
		-- Attacking set to false so player can move again
		attacking = false
		-- Sets the animation back to what it was when the player attacked
		msg.post("#sprite", "play_animation", { id = anim })
	end
	-- Goes off if the player hits the key to switch weapons
	if message_id == hash("switch") then
		-- Checks that the weapon timer is at 0
		if weaponSwitchTimer == 0 then
			-- sets the timer
			weaponSwitchTimer = 100
			-- Changes the attack type boolean
			attackMelee = not attackMelee
		end
	end

	-- if message is an attack collision and the player is not in the cooldown state...
	if message_id == hash("contact_point_response") and self.damage_cooldown == 0 and message.other_group == hash("enemy_body") or message.other_group == hash("enemy_attack") then
		anim = self.current_anim
		on_damage(self, message.normal,true)
	end

	if message_id == hash("trigger_response") and self.damage_cooldown == 0 and message.other_group == hash("enemy_body") then
		anim = self.current_anim
		on_damage(self, message.normal,false)
	end

	if message_id == hash("trigger_response") and message.enter == true and message.other_group == hash("itemrange") then
		self.in_item_range = true
		self.itemNear = message.other_id
		print(self.itemNear)
	elseif message_id == hash("trigger_response") and message.enter == false and message.other_group == hash("itemrange") then
		self.in_item_range = false
		self.itemNear = hash("")
	end

	if message_id == hash("key_2_created") then
		self.key2id = message.key_id
		print(self.key2id)
	end

	if message_id == hash("contact_point_response") and message.other_group == hash("walls") then
		if message.distance > 0 then
			-- Calculate correction vector to move player out of the wall
			local correction = message.normal * message.distance
			-- Apply correction to player's position
			go.set_position(go.get_position() + correction)
		end
	end

	if message_id == hash("contact_point_response") and message.other_group == hash("enemy_walls") then
		if self.keys == 0 then
			if message.distance > 0 then
				-- Calculate correction vector to move player out of the wall
				local correction = message.normal * message.distance
				-- Apply correction to player's position
				go.set_position(go.get_position() + correction)
			end
		else
			if roofVisible then
				tilemap.set_visible("/level#generateMap", "roof", false)
				tilemap.set_visible("/level#generateMap", "roof2", false)
				roofVisible = false
			end
		end
	end

	if message_id == hash("contact_point_response") and message.other_group == hash("exit_doors") then
		if self.keys < 2 then
			if message.distance > 0 then
				-- Calculate correction vector to move player out of the wall
				local correction = message.normal * message.distance
				-- Apply correction to player's position
				go.set_position(go.get_position() + correction)
			end
		else
			if exitDoorsVisible then
				tilemap.set_visible("/level#generateMap", "locked_doors", false)
				exitDoorsVisible = false
			end
		end
	end
end

function on_input(self, action_id, action)
	-- if in knockback state then take no user input
	if not self.knocked_back then
		-- Recieves input as designated in the game file
		-- If it is a movement key, it sets the intenal direction of the player
		if action_id == hash("down") and dt ~= 0 then                        -- [1]
			self.dir.y = -1
		elseif action_id == hash("up") and dt ~= 0 then
			self.dir.y = 1
		elseif action_id == hash("left") and dt ~= 0 then                     -- [2]
			self.dir.x = -1
		elseif action_id == hash("right") and dt ~= 0 then
			self.dir.x = 1
		-- If it is attack, it sends a message to attack to itself
		elseif action_id == hash("attack") and dt ~= 0 then
			msg.post(".", "play attack")
		-- If it is to switch weapons, it sends a message to itself to switch
		elseif action_id == hash("switch") and dt ~= 0 then
			msg.post(".", "switch")
		elseif action_id == hash("interact") and self.in_item_range then
			weaponAcquired = true
			if self.itemNear == hash("/MeleeItem") and meleeWeaponAcquired == false then
				self.itemNear = hash("")
				print("Knife!")
				meleeWeaponAcquired = true
				msg.post("/MeleeItem#item", "picked_up")
			elseif self.itemNear == hash("/RangedItem") and rangedWeaponAcquired == false then
				self.itemNear = hash("")
				print("Rockets!")
				rangedWeaponAcquired = true
				msg.post("/RangedItem#item", "picked_up")
				if attackMelee then
					attackMelee = false
				end
			elseif self.itemNear == self.key2id then
				self.itemNear = hash("")
				print("key obtained!")
				self.keys = self.keys + 1
				msg.post(self.key2id, "picked_up")
				print(self.keys)
			end
		end
	end
end
